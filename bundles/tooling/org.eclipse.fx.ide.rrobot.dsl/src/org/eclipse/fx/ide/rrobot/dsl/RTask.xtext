// automatically generated by Xtext
grammar org.eclipse.fx.ide.rrobot.dsl.RTask with org.eclipse.xtext.common.Terminals

import "http://www.efxclipse.org/rrobot/task/bundle/1.0" as bundle
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.efxclipse.org/rrobot/task/1.0" as task

RobotTask returns task::RobotTask:
	{task::RobotTask}
	'RobotTask'
	'{'
		('variables' '=' '{' variables+=Variable ( "," variables+=Variable)* '}')?
		('projects' '=' '{' projects+=GenericProject ( "," projects+=GenericProject)* '}' )?
	'}';

Variable returns task::Variable:
	description=SL_DOC
	type=Type key=STRING ('default' defaultValue=STRING)?
;

enum Type returns task::Type:
	BOOLEAN | DOUBLE | INT | STRING
;


GenericProject returns task::Project:
	Project | BundleProject | FeatureProject
;

Resource returns task::Resource:
	Folder | TemplatedFile | DataFile | URLFile | DynamicFile | ManifestFile | ProductFileFeaturebase | PluginXMLFile | ComponentDefinitionFile;

Project returns task::Project:
	{task::Project}
	'SimpleProject' name=EString
	'{'
		('resources' '=' '{' resources+=Resource ( "," resources+=Resource)* '}' )?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?;

EString returns ecore::EString:
	STRING | ID;

Folder returns task::Folder:
	{task::Folder}
	'Folder'
	name=EString
	('{'
		'children' '=' '{' children+=Resource ( "," children+=Resource)* '}'
	'}')?;

TemplatedFile returns task::TemplatedFile:
	{task::TemplatedFile}
	'TemplatedFile'
	name=EString
	'{'
		('generatorType' '=' generatorType=EString)?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?;

DataFile returns task::DataFile:
	{task::DataFile}
	'DataFile'
	name=EString
	'{'
		('content' '=' content=EByteArray)?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?;

URLFile returns task::URLFile:
	{task::URLFile}
	'URLFile'
	name=EString uri=EString
	('excluded-if' excludeExpression=BooleanExpression)?;

DynamicFile returns task::DynamicFile:
	{task::DynamicFile}
	'DynamicFile' name=EString 'generated-from' executionURI=STRING 'by' type=STRING
	('{' variables+=Variable (',' variables+=Variable)* '}')?
	('excluded-if' excludeExpression=BooleanExpression)?
;

ComponentDefinitionFile returns bundle::ComponentDefinitionFile:
	{bundle::ComponentDefinitionFile}
	'ComponentDefinition' name=EString '{'
		(
			'name' '=' id=EString
			&
			'class' '=' componentClass=EString
		)
		'services' '=' '{' serviceInterfaceList+=EString (',' serviceInterfaceList+=EString)* '}'
		'references' '=' '{' referenceList+=ComponentReference (',' referenceList+=ComponentReference)* '}'
	'}'
;

ComponentReference returns bundle::ComponentReference:
	{bundle::ComponentReference}
	name=ID '{'
		(
			'bind' '=' bind=ID
			&
			'unbind' '=' unbind=ID
			&
			'class' '=' typeName=EString
			&
			'cardinality' '=' cardinality=Cardinality
			&
			'policy' '=' policy=Policy
		)
	'}'
;

enum Cardinality returns bundle::Cardinality:
	SINGLE_OPTIONAL | SINGLE_REQUIRED | MULTI_OPTIONAL | MULTI_REQUIRED
;
enum Policy returns bundle::Policy:
	DYNAMIC | STATIC
;

BooleanExpression returns task::BooleanExpression:
	ReferencingBooleanExpression | InlineBooleanExpression
;

ReferencingBooleanExpression returns task::ReferencingBooleanExpression:
	executionURI=STRING 'by' type=STRING
;

InlineBooleanExpression returns task::InlineBooleanExpression:
	type=STRING expression=INLINE_SCRIPT
;


EByteArray returns ecore::EByteArray:
	EString /* TODO: implement this rule and an appropriate IValueConverter */
;

BundleProject returns bundle::BundleProject:
	{bundle::BundleProject}
	'BundleProject'
	name=EString '{'
		(
			'manifest' '=' manifest=ManifestFile
			&
			'build' '=' buildProperties=BuildProperties
			&
			('pluginxml' '=' pluginxml=PluginXMLFile)?
		)
		('resources' '=' '{' resources+=Resource ( "," resources+=Resource)* '}' )?
		'rootfragments' '=' '{' sourceFragments+=SourceFragment ( "," sourceFragments+=SourceFragment)* '}'
		('compilation-units' '=' '{' compilationUnits+=CompilationUnit (',' compilationUnits+=CompilationUnit)* '}')?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?
;

SourceFragment returns task::SourceFragment:
	'fragment' name=EString folder=[task::Folder|STRING]
;

CompilationUnit returns task::CompilationUnit:
	packagename=STRING 'in' sourcefragment=[task::SourceFragment|STRING] '{' file=(TemplatedFile | DataFile | URLFile | DynamicFile) '}'
	('excluded-if' excludeExpression=BooleanExpression)?
;


FeatureProject returns bundle::FeatureProject:
	{bundle::FeatureProject}
	'FeatureProject'
	name=EString '{'
		'feature' '=' feature=FeatureFile
		('resources' '=' '{' resources+=Resource ( "," resources+=Resource)* '}' )?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?
;

ManifestFile returns bundle::ManifestFile:
	{bundle::ManifestFile}
	lazy?='lazy'? singleton?='singleton'? 'ManifestFile' symbolicname=STRING version=STRING executionEnvironment=STRING '{'
		(
			'bundlename' '=' bundlename=STRING
			&
			'vendor' '=' vendor=STRING
			&
			('activatorClass' '=' activatorClass=STRING)?
		)
		('exportedPackages' '=' '{'exportedPackages+=ExportedPackage ( ',' exportedPackages+=ExportedPackage )* '}')?
		('importedPackages' '=' '{'importedPackages+=ImportedPackage ( ',' importedPackages+=ImportedPackage )* '}')?
		('requiredBundles' '=' '{'requiredBundles+=RequiredBundle ( ',' requiredBundles+=RequiredBundle )* '}')?
	'}'
;

PluginXMLFile returns bundle::PluginXMLFile:
	{bundle::PluginXMLFile}
	'PluginXMLFile' '{'
		('extensions' '=' '{'extensions+=Extension ( ',' extensions+=Extension )* '}')?
	'}'
;

BuildProperties returns bundle::BuildProperties:
	{bundle::BuildProperties}
	'BuildProperties' '{'
		('binIncludes' '=' '{' binIncludes+=[task::Resource|STRING] ( ',' binIncludes+=[task::Resource|STRING] )* '}')?
	'}'
;

ProductFileFeaturebase returns bundle::ProductFileFeaturebase:
	{bundle::ProductFileFeaturebase}
	includeLaunchers?='launchable'? 'ProductFileFeaturebase' id=STRING '{'
		(
			('vmArgs' '=' vmArgs=STRING)?
			&
			('programArgs' '=' programArgs=STRING)?
			&
			'productName' '=' productName=STRING
			&
			'application' '=' application=STRING
			&
			'version' '=' version=STRING
		)
		('startconfigurations' '=' '{'
			startconfigurations+=ProductStartConfig ( ',' startconfigurations+=ProductStartConfig )*
		'}')?
		('features' '=' '{'
			features+=ProductFeature ( ',' features+=ProductFeature )*
		'}')?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?;

FeatureFile returns bundle::FeatureFile:
	{bundle::FeatureFile}
	'FeatureFile' featureid=STRING '{'
		(
			'version' '=' version=STRING
			&
			'featurename' '=' featurename=STRING
			&
			'vendor' '=' vendor=STRING
			&
			'description' '=' description=LinkedString
			&
			'copyright' '=' copyright=LinkedString
			&
			'license' '=' license=LinkedString
			&
			('license-feature' '=' license_feature=STRING
			&
			'license-feature-version' '=' license_feature_version=Version)?
		)
		('plugins' '=' '{'
			plugins+=FeaturePlugin (',' plugins+=FeaturePlugin)*
		'}')?
		('required' '=' '{' requiredfeatures+=RequiredFeature (',' requiredfeatures+=RequiredFeature)* '}' )?
		('included' '=' '{' includedfeatures+=IncludedFeature (',' includedfeatures+=IncludedFeature)* '}' )?
	'}'
;

ImportedPackage returns bundle::ImportedPackage:
	{bundle::ImportedPackage}
	name=STRING ((minExclusive?='('? | '[') minVersion=Version? ',' (maxVersion=Version? (maxExclusive?=')'? | ']')))?
	('excluded-if' excludeExpression=BooleanExpression)?
;

ExportedPackage returns bundle::ExportedPackage:
	{bundle::ExportedPackage}
	name=STRING version=Version?
	('excluded-if' excludeExpression=BooleanExpression)?
;

Extension returns bundle::Extension:
	{bundle::Extension}
	point=STRING '{'
		('id' '=' id=STRING)?
		('elements' '=' '{'
			elements+=Element (',' elements+=Element)*
		'}')?
	'}'
	('excluded-if' excludeExpression=BooleanExpression)?
;

Element returns bundle::Element:
	{bundle::Element}
	name=STRING '{'
		('attributes' '=' '{'
			attributes+=Attribute (',' attributes+=Attribute)*
		'}')?
		('children' '=' '{'
			children+=Element (',' children+=Element)*
		'}'
		)?
	'}'
;

Attribute returns bundle::Attribute:
	{bundle::Attribute}
	'{'name=STRING ',' value=STRING'}'
;

RequiredBundle returns bundle::RequiredBundle:
	{bundle::RequiredBundle}
	name=STRING ((minExclusive?='('? | '[') minVersion=Version? ',' maxVersion=Version? (maxExclusive?=')'? | ']'))?
	('excluded-if' excludeExpression=BooleanExpression)?
;

LinkedString returns bundle::LinkedString:
	{bundle::LinkedString}
	'LinkedString' weburl=STRING '{'
		value=STRING
	'}'
;

FeaturePlugin returns bundle::FeaturePlugin:
	{bundle::FeaturePlugin}
	unpack?='unpacked'? ^fragment?='fragment'? id=STRING
	('excluded-if' excludeExpression=BooleanExpression)?
;

RequiredFeature returns bundle::RequiredFeature:
	{bundle::RequiredFeature}
	id=STRING match=MatchRule version=Version
	('excluded-if' excludeExpression=BooleanExpression)?
;

IncludedFeature returns bundle::IncludedFeature:
	{bundle::IncludedFeature}
	id=STRING version=Version?
	('excluded-if' excludeExpression=BooleanExpression)?
;

//ProductPlugin returns bundle::ProductPlugin:
//	{bundle::ProductPlugin}
//	id=STRING version=Version?
//;

ProductFeature returns bundle::ProductFeature:
	{bundle::ProductFeature}
	id=STRING version=STRING?
	('excluded-if' excludeExpression=BooleanExpression)?
;

ProductStartConfig returns bundle::ProductStartConfig:
	{bundle::ProductStartConfig}
	id=STRING (autoStart?='autostarted' ('at' startLevel=(SIGNED_INT|INT))? )?
	('excluded-if' excludeExpression=BooleanExpression)?
;

Version returns bundle::Version:
	INT '.' INT '.' INT ('.' ID)? /* TODO: implement this rule and an appropriate IValueConverter */
;

enum MatchRule returns bundle::MatchRule:
	none | equivalent | compatible | perfect | greaterOrEqual
;

terminal SL_DOC:
	'##' !('\n'|'\r')* ('\r'? '\n')?;

terminal INLINE_SCRIPT:
	'/#' -> '#/'
;

terminal SIGNED_INT returns ecore::EInt:
	'-' INT
;

//QualifiedName:
//  ID (=>'.' ID)*;